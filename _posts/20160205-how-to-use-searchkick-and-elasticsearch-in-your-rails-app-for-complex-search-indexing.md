title: How to Use Searchkick and ElasticSearch in Your Rails App For Complex Search Indexing
link: http://aimeeault.com/2016/02/05/how-to-use-searchkick-and-elasticsearch-in-your-rails-app-for-complex-search-indexing/
author: aimeeault
description: 
post_id: 1642
created: 2016/02/05 23:44:30
created_gmt: 2016/02/05 23:44:30
comment_status: open
post_name: how-to-use-searchkick-and-elasticsearch-in-your-rails-app-for-complex-search-indexing
status: publish
post_type: post

# How to Use Searchkick and ElasticSearch in Your Rails App For Complex Search Indexing

For reasons that elude me, I have always been obsessed with "speedcoding." That is, I like to see how fast I can implement a very large feature in a ridiculously short amount of time. I won't lie: this kind of trait goes hand-in-hand with phrases like "cowboy coding" and "Balmer peak," and with age, I've largely outgrown it, but the mood still hits me every now and then. I recently enjoyed one of these moments while toying around with some code for [Treehouse](http://teamtreehouse.com), for the fun of it. ![imageedit_5_3400066282](/wp-content/uploads/2016/02/imageedit_5_3400066282.gif) In a past life, I spent about a year working on a team for [DeviantArt](http://www.deviantart.com) whose sole purpose was to improve search results on the site. If you were not aware, DeviantArt's search is done entirely in-house by people who have PhDs in math. They're brilliant people who will talk your ears off about facets, scoring, histograms, and tagging metadata. I didn't work on any of the search indexing services myself (which were all written in C++), but I was heavily exposed to the bits of it that were included in the main app, written in PHP. And as a result of that, I know more about search indexing than I'd like to say I know. 

### CloudSearch or Ransack?

So, seeing poorly implemented search indexing tools also causes me mental anguish. That's how I feel about [Amazon CloudSearch](https://aws.amazon.com/cloudsearch/), in general, which is a tool Treehouse has used for one of its most major site features. It's not the worst indexing tool in the world but I really dislike that you have to hit your indices through an API since it's all hosted externally, which seems unnecessary, unlike hitting a CDN for assets. That's like hosting your Redis stores on a third-party service: why. But, worse, for a few internal tools, Treehouse uses a Rails gem called _[Ransack](https://github.com/activerecord-hackery/ransack)._ I don't _mind_ Ransack. It has its heart in the right place, but it leverages ActiveRecord for its querying and so, you'll have to put a _lot_ of effort into optimizing indices on your database tables if you expect it to work even halfway decently as the size of the table you're querying grows. This also assumes you're not doing expensive table joins as part of your query. 

### Searchkick to the Rescue

I recently decided to see what would happen if I used ElasticSearch for a fairly complex search, using a gem called [Searchkick](https://github.com/ankane/searchkick). I really like Searchkick because out-of-the-box, there's no configuration needed. If you want to index your User model, it's as simple as adding the gem to your Gemfile and a `searchkick` directive to the class: ` source "https://rubygems.org" ruby "2.2.3" ... gem "searchkick" ... ` ` class User < ActiveRecord::Base searchkick end ` And then reindexing the model: ` pry(main)> User.reindex ` The cool thing here is that you can also do your reindexing asynchronously so that it won't block processes or have a dramatic impact on your application's performance. You can then search all attributes of `User` (i.e. name, e-mail, city) like so: ` pry(main)> User.search("bob") ` And you'll find plenty of demos and tutorials for that all over the place, but who ever needs the simplest use case? 

#### I had a few different needs:

1\. Because Searchkick uses ElasticSearch, you can't chain scopes off of the model prior to running the search like so: ` pry(main) > User.active.search("bob") ` I mean, you can, but -- it'll ignore the named scope and still run your search against _all_ `User` records. So I needed to be able to account for different scopes, and the above piece of code simply does not work and cannot be made to work. 2\. I needed to be able to sort my results by a variety of things which weren't necessarily attributes on the model itself. For example: I needed to sort by the time difference between the model's `created_at` attribute and its `updated_at` attribute. Or I needed to sort by the `created_at` timestamp on a child association. ElasticSearch's DSL supports a sort order constraint, but how do you sort by a value that isn't indexed with the model? 3\. As I started to index more things, I noticed my controller logic was growing wily. I needed some sort of presenter type class or simply a PORO to organize my Searchkick search. So I'm going to walk through how I developed this search feature, stopping to explain my thought process along the way. Because I didn't feel like getting sued by my employer for any potential intellectual property theft, I've used a completely different search feature that has absolutely nothing to do with what I was originally building a search for. Once I was finished writing this code, I was able to roll out a second sortable, filterable, search tool for another model in about 20 minutes reusing the same pattern. 

### Where I Started

I wanted to index a model called `Movie`. Each `Movie` is directed by a `Director` and has many `Actor`s through a relational model called `ActorRole`. Searchkick allows you to override which columns are used in searches via a method called `search_data`. My first step is to find out what things I need to index here! ` class Movie < ActiveRecord::Base searchkick belongs_to :director has_many :actor_roles has_many :actors, through: :actor_roles def search_data attrs = attributes.dup relational = { director_name: director.name, actor_names: actors.map(&:name) } attrs.merge! relational end end ` What this does is allow me to continue indexing the attributes on the model itself, but also includes a couple of other pieces of denormalized data from associations, namely the name of the `Director` who directed the Movie and the names of anyone who acted in the movie, both pieces of data that are _not_ stored on the Movie record. So, assuming that I have a Movie with the title "[The Room](https://www.youtube.com/watch?v=aYRydundnt8)" directed by esteemed actor, director, and writer Tommy Wiseau, I can now search for "Tommy Wiseau" and "The Room" will be one of my search results--both because he acted in the movie and directed it. If you're used to working with relational databases, seeing denormalized data stored this way might bother you, but it shouldn't. Remember, the purpose of these indices is for aiding in searching, not for data management. Your indices do not need to look pretty--they need to simply be a collection of values that you search with, mapped to their respective data types. That's _why_ it's a separate data store from your primary database, afterall. **You should always reindex after making changes to the search attributes, so that ElasticSearch can pick up anything new.**

### Implementing This In A Controller

` class MoviesController < ApplicationController def index query = params[:q].presence || "*" @movies = Movie.search(query, { page: params[:page], per_page: 20 }) end end ` As you can see, the search method, provided by Searchkick, takes 2 parameters. The first is a query string. The second is an options hash. Already, I'm passing two options to set up pagination support. You might imagine how hairy this will start to get once I need to do more complex search functionality. **I'd like to move this logic into its own service object for a couple of reasons:** 1\. I'm a big fan of keeping controller actions skinny (as most Sandi Metz fans are) 2\. If I later decide to add additional searches, I am likely going to reuse this logic. So let's do that. ` class MovieSearch attr_reader :query, :options 
  *[PORO]: Plain Old Ruby Object

## Comments

**[Erik Escobedo](#552 "2016-05-22 17:00:51"):** This is a great article and I found exactly what I was looking for. Thank you very much! PS: search for `, options)` and you'll find a couple of errors on the snippets :)

**[Denis](#952 "2016-09-15 16:43:39"):** Thanks, this article saved me a lot of time and taught me a few new things. Wish you could dive deeper and cover Highlight and cross-field searching features. Thanks again!

